HOW TO BUILD A MPLAB HARMONY APPLICATION

This is a general MPLAB Harmony template for the PIC32 family of
microcontrollers. It's purpose is to provide a project shell for users to get
started designing their own MPLAB Harmony applications.  Final qualification and
testing of this project is left to the user.  In addition to the steps below,
TODO tags have been added to this template which work with the "Tasks" feature
of MPLAB.

STEP 1

First install the appropriate C compiler if you have not done so already.

See www.microchip.com/compilers

STEP 2

If you have not already done so, install into MPLAB X the MPLAB Harmony Help and
MPLAB Harmony Configuration Wizard Plug In Modules.  Directions for installing
these can be found in the "Before you Start Section" of the help file or in the
readme file in the MPLAB Harmony installation directory.  A standalone MPLAB
Harmony Help file can be found in the doc folder of your MPLAB Harmony
installation or can be accessed in Windows from the
Start Menu -> Microchip -> MPLAB Harmony menu selection.

STEP 3

Select the configuration (pic32mx or pic32mz) from the configuration drop down
box in MPLAB X. If you are not familiar with this feature, see the "Work with
Multiple Configurations" of the "Advanced Tasks" section of the MPLAB X Help.
These configurations are provided to kick start your development and can be
modified, removed or replaced.

Build this project by clicking the Clean and Build Icon (the hammer and broom
symbol) in the MPLAB X IDE Toolbar. If this project builds, then you are ready
to make changes for your own application.  If the project does not build, you
need to troubleshoot why the project does not build before moving on.

STEP 4

Determine which MPLAB Harmony Modules are needed for your Application.
Modules are divided into four categories; Peripheral Libraries, System Services,
Device Drivers and other libraries (commonly called middleware). To determine
your needs read the overview of MPLAB Harmony and the Introductory sections for
the modules of interest. Some modules have dependencies while others do not.
Peripheral Libraries have no dependencies. Drivers depend on peripheral
libraries.  System Services depend on Peripheral Libraries and or Drivers. Your
application or its middleware will typically use drivers or system services.

STEP 5

Add the required Module Source Files to your Project. This can be accomplished
by reading the help for each module to determine what source files you need and
manually entering them into your project.  Alternatively, the MPLAB Harmony
Configuration Wizard can be used to select the modules from a list or tree and
it will automatically insert the source files into your project and optionally
generate a skeletal template for your project.

Note that some modules have multiple implementations each optimized for
different purposes.  Others may implement optional features in multiple files.
Be sure to select the source file right for your implementation and be sure to
include the pre-built peripheral library binary ".a" file for the processor you
selected in your project.

STEP 6

Configure The Modules. With the exceptions of the Peripheral Libraries, every
MPLAB Harmony module will require some set of build time configuration options
implemented using 'c' language macros ?#define?. Descriptions of the supported
options are available in the "Configuring the Library" section in the help
document for every MPLAB Harmony library. These options must be defined in the
system_config.h header that is part of your project template generated by the
MPLAB Harmony Configuration Wizard. Every MPLAB Harmony source file that
supports build time configuration options will include this header. As such,
this file must be part of every MPLAB Harmony Project.

STEP 7

Initialize the System. This task involves completing the system_init.c file.
First add the necessary configuration bits for your processor.  These are
defined in the Special Features Section of your devices datasheet.
The next step is to complete the SYS_Initialize function.  Finish any necessary
processor initialization (wait states, cache control, etc.)  MPLAB Harmony may
provide services to accomplish this in the System Services Module.  Initialize
any features specific to the board that are not initialized by other modules
such as drivers or system services. Next, initialize all library modules
selected in step 4 above used by your application. To do this you must first
define the initialization data structure for each module.   This can be done
statically in the system_init.c file and passed in by pointer to the appropriate
initialization function for each library. Needed initialization structures can
be found in the help section for each module. Add a call to the initialization
function for each library module into the SYS_Initialize function.  Each
initialization function will return an object handle for the module instance.
These should be captured so that they can be passed to the module task routine.
Finally, add the call to APP_Initialize function into the SYS_Initialize
function.

STEP 8

Call System State Machine Tasks. The system must call the various task state
machine functions at appropriate times.  This is accomplished by either adding
the call into the SYS_Tasks function for polled modules or adding the call to
the interrupt handler for interrupt driven modules.  The object handle saved
during the initialization process is used as an argument for the various task
state machine functions. The SYS_Tasks function is typically implemented in the
system_tasks.c file while the interrupt handlers are defined in the system_int.c
file.

STEP 9

Develop Application State Machine. You are now ready to develop your
application.  Since MPLAB Harmony is based on cooperative state machines, your
application should also be state machine driven.  At minimum, the APP_Initialize
function must put your application in its initial state. It may perform other
initialization as long as it does not have to wait for other modules.  Any
initialization that depends on other modules should be implemented as part of
the application state machine. Finally complete your application functionality
by implementing the APP_Tasks state machine function.
